var exports = {
    establish_connection : async function (key) {
        return new Promise((resolve, reject) => {
            if(!key.host || !key.username || !key.password) {
                reject({
                    err: 'required configuration options not set for pgsql connection',
                    step: 'establish_connection (pgsql variant)',
                    description: 'invalid configuration object provided to lazy_sql automated step',
                    resolution: `please provide supported value for ${!key.host ? 'host' : ''} ${!key.username ? 'username' : ''}
                    ${!key.password ? 'password' : ''} in configuration object, additional details can be found in the documentation`
                })
            }
            var { Pool, Client } = require('pg')
            var pool = new Pool({
                host: key.host,
                user: key.username,
                password: key.password,
                port: 3211
            })
            pool.on('error', (err, client) => {
                reject({
                    err: 'pgsql connection was invalid',
                    step: 'establish_connection (pgsql variant)',
                    description: 'Unexpected error on idle client: ' + err,
                    resolution: `please check your connection to the pgsql client`
                    })
                process.exit(-1)
              })
            resolve(pool)
        })
    },
    run_query : async function (pool, sql_query, repeat_number, max_repeat) {
        return new Promise(async (resolve, reject) => {
            // Automatically retry each query up to 25 times before erroring out
            if(!max_repeat) {max_repeat = 25}
            pool.connect((err, conn) => {
                if (err) {
                    reject({
                        err: 'pgsql connection errored',
                        step: 'establish_connection (pgsql variant)',
                        description: err,
                        resolution: `please check your SQL server authentication details and SQL server firewall`
                    })
                }
                conn.query(sql_query, (err, results) => {
                    if (err) {
                        if(repeat_number) {repeat_number = repeat_number + 1}
                        else {repeat_number = 1}
                        if (repeat_number < max_repeat) {
                            var nested_query = await exports.run_query(pool, sql_query, repeat_number)
                            if(!nested_query.err) {resolve ({err: nested_query.err, 
                                results: nested_query.results
                            })}
                        } else {
                            conn.release()
                            console.log(sql_query.substring(0,50) + '... errored ' + repeat_number + ' times')
                            reject({
                                err: 'mysql query errored',
                                step: 'run_query (mysql variant)',
                                description: sql_query.substring(0,50) + '... errored ' + repeat_number + ' times',
                                resolution: `please check this query as an invalid query may have been passed. If this query was generated by the Lazy_SQL module, 
                                please raise a bug report on https://github.com/walterchoi/Lazy_SQL/issues`
                            })
                        }
                    } else {
                        if(repeat_number > 0) {
                            console.log(sql_query.substring(0,50) + '... errored ' + repeat_number + ' times but completed successfully')
                        }
                        conn.release()
                        resolve({
                            results: results
                        })
                    }
                })
            })
        })
    },
    check_database_exists = function (database) {
        var sql_query_part = ""
        // Handle multiple databases being provided as an array
        if(database.isArray) {
            for (var d = 0; d < database.length; d++) {
                sql_query_part = sql_query_part +
                "(CASE WHEN EXISTS (SELECT NULL FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '" + database[d] + "') THEN 1 ELSE 0 END) AS '" + database[d] + "'"
                if(d != database.length - 1) {sql_query_part = sql_query_part + ', '}
            }
        } else {
            // Handle multiple databases being provided
            sql_query_part = 
            "(CASE WHEN EXISTS (SELECT NULL FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '" + database + "') THEN 1 ELSE 0 END) AS '" + database + "' "
        }
        
        var sql_query = "SELECT " + sql_query_part + ";"
        return (sql_query)
    },
    create_database : function (config) {
        var database = config.database;
        var sql_query = 'CREATE SCHEMA "' + database + '";'
        return(sql_query)
    },
    check_tables_exists = function (database, table) {
        var sql_query_part = ""
        // Handle multiple tables being provided as an array
        if(table.isArray) {
            for (var t = 0; t < table.length; t++) {
                sql_query_part = sql_query_part +
                "(CASE WHEN EXISTS (SELECT NULL FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '" + database + "' AND TABLE_NAME = '" + table[t] + "') THEN 1 ELSE 0 END) AS '" + table[t] + "'"
                if(t != tables.length - 1) {sql_query_part = sql_query_part + ', '}
            }
        } else {
            // Handle multiple tables being provided
            sql_query_part = 
            "(CASE WHEN EXISTS (SELECT NULL FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '" + database + "' AND TABLE_NAME = '" + table[t] + "') THEN 1 ELSE 0 END) AS '" + table[t] + "'"
        }
        var sql_query = "SELECT " + sql_query_part + ";"
        return (sql_query)
    }
}

            module.exports = {
                exports
            }