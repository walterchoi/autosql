var exports = {
    establish_connection : async function (key) {
        return new Promise((resolve, reject) => {
            if(!key.host || !key.username || !key.password) {
                reject({
                    err: 'required configuration options not set for pgsql connection',
                    step: 'establish_connection (pgsql variant)',
                    description: 'invalid configuration object provided to lazy_sql automated step',
                    resolution: `please provide supported value for ${!key.host ? 'host' : ''} ${!key.username ? 'username' : ''}
                    ${!key.password ? 'password' : ''} in configuration object, additional details can be found in the documentation`
                })
            }
            var { Pool, Client } = require('pg')
            var pool = new Pool({
                host: key.host,
                user: key.username,
                password: key.password,
                port: key.port
            })
            pool.on('error', (err, client) => {
                reject({
                    err: 'pgsql connection was invalid',
                    step: 'establish_connection (pgsql variant)',
                    description: 'Unexpected error on idle client: ' + err,
                    resolution: `please check your connection to the pgsql client`
                    })
                process.exit(-1)
              })
            resolve(pool)
        })
    },
    run_query : async function (config, sql_query, repeat_number, max_repeat) {
        return new Promise(async (resolve, reject) => {
            var pool = config.connection
            // Automatically retry each query up to 25 times before erroring out
            if(!max_repeat) {max_repeat = 25}
            console.log(sql_query)
            pool.connect()
            .then(client => {
                return client
                .query(sql_query)
                    .then(results => {
                    if(repeat_number > 0) {
                        console.log(sql_query.substring(0,50) + '... errored ' + repeat_number + ' times but completed successfully')
                    }
                    client.release()
                    resolve({
                        results: results.rows
                    })
                })
                .catch(async err => {
                    console.log(err)
                    if(repeat_number) {repeat_number = repeat_number + 1}
                        else {repeat_number = 1}
                        if (repeat_number < max_repeat) {
                            var nested_query = await exports.run_query(pool, sql_query, repeat_number)
                            if(!nested_query.err) {resolve ({err: nested_query.err, 
                                results: nested_query.results
                            })}
                        } else {
                            client.release()
                            console.log(sql_query.substring(0,50) + '... errored ' + repeat_number + ' times')
                            reject({
                                err: err,
                                step: 'run_query (pgsql variant)',
                                description: sql_query.substring(0,50) + '... errored ' + repeat_number + ' times',
                                resolution: `please check this query as an invalid query may have been passed. If this query was generated by the Lazy_SQL module, 
                                please raise a bug report on https://github.com/walterchoi/Lazy_SQL/issues`
                            })
                        }
                    }
                )}
            )}
        )
    },
    check_database_exists : function (config) {
        var database = config.database;
        var sql_query_part = ""
        // Handle multiple databases being provided as an array
        if(database.isArray) {
            for (var d = 0; d < database.length; d++) {
                sql_query_part = sql_query_part +
                "(CASE WHEN EXISTS (SELECT NULL FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '" + database[d] + `') THEN 1 ELSE 0 END) AS "` + database[d] + `"`
                if(d != database.length - 1) {sql_query_part = sql_query_part + ', '}
            }
        } else {
            // Handle multiple databases being provided
            sql_query_part = 
            "(CASE WHEN EXISTS (SELECT NULL FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '" + database + `') THEN 1 ELSE 0 END) AS "` + database + `"`
        }
        var sql_query = "SELECT " + sql_query_part + ";"
        return (sql_query)
    },
    create_database : function (config) {
        var database = config.database;
        var sql_query = 'CREATE SCHEMA "' + database + '";'
        return(sql_query)
    },
    check_tables_exists : function (config) {
        var database = config.database;
        var table = config.table;
        console.log(table)
        var sql_query_part = ""
        // Handle multiple tables being provided as an array
        if(table.isArray) {
            for (var t = 0; t < table.length; t++) {
                sql_query_part = sql_query_part +
                "(CASE WHEN EXISTS (SELECT NULL FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '" + database + "' AND TABLE_NAME = '" + table[t] + `') THEN 1 ELSE 0 END) AS "` + table[t] + '"'
                if(t != tables.length - 1) {sql_query_part = sql_query_part + ', '}
            }
        } else {
            // Handle multiple tables being provided
            sql_query_part = 
            "(CASE WHEN EXISTS (SELECT NULL FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '" + database + "' AND TABLE_NAME = '" + table + `') THEN 1 ELSE 0 END) AS "` + table + '"'
        }
        var sql_query = "SELECT " + sql_query_part + ";"
        return (sql_query)
    },
    create_table : function (config, headers, override) {
        return new Promise((resolve, reject) => {
            var sql_dialect_lookup_object = require('../config/sql_dialect.json')
            var sql_lookup_table = require('.' + sql_dialect_lookup_object[config.sql_dialect].helper_json)
    
            var database = config.database;
            var table = config.table;
            var collation = config.collation;

            var create_table_sql = `CREATE TABLE IF NOT EXISTS "` + database + `"."` + table + `" (\n`
    
            var primary_sql_part = null
            var create_table_sql_part = null
            var index_create_sql = ''
            var auto_increments_sql = ''
            // Get each column's data and repeat for each meta_data row
            for (var h = 0; h < headers.length; h++) {
                var header_name = (Object.getOwnPropertyNames(headers[h])[0])
                var header_data = headers[h][header_name]
                
                // Set variables required for create table statement
                var column_name = header_name
                var type = header_data["type"]
                var length = header_data["length"]
                var decimal = header_data["decimal"]
                var allowNull = header_data["allowNull"]
                var unique = header_data["unique"]
                var primary = header_data["primary"]
                var index = header_data["index"]
                var auto_increment = header_data["auto_increment"]
                var def = header_data["default"]
                var comment = header_data["comment"]
                
                if(sql_lookup_table.translate[header_data["type"]]) {
                    type = sql_lookup_table.translate[header_data["type"]]
                }
    
                if(create_table_sql_part) {
                    create_table_sql_part = `,\n "` + column_name + `" ` + type 
                } else {
                    create_table_sql_part = `"` + column_name + `" ` + type 
                }
    
                if(sql_lookup_table.decimals.includes(type)) {
                    if(!decimal) {decimal = 0}
                    create_table_sql_part += " (" + length + "," + decimal + ")"
                }
                else if(sql_lookup_table.require_length.includes(type) || (sql_lookup_table.optional_length.includes(type) && length)) {
                    create_table_sql_part += " (" + length + ")"
                }
                
                // If allowNull is true/false add (NOT) NULL to SQL part
                if(allowNull !== undefined) {
                    create_table_sql_part += ` ${!allowNull ? 'NOT' : ''} NULL`
                }
    
                // If unique is true then make this an unique contraint column
                if(unique === true) {
                    create_table_sql_part += " UNIQUE"
                }
    
                // If index is true then make column into an indexed column (separate query done later)
                if(index === true) {
                    index_create_sql += `CREATE INDEX CONCURRENTLY "${table + '_' + column_name}" ON "${table}" ("${column_name}");\n`
                }

                // If auto_increment is true then make column into an auto_incremental column (separate query done later)
                if(auto_increment === true) {
                    auto_increments.push(column_name)
                    if(def !== undefined) {
                        reject({
                            err: 'default value was specified for an auto_increment column',
                            step: 'create table (pgsql variant)',
                            description: `${column_name} has been specified as an auto_incremental column with a default value`,
                            resolution: `please check the ${column_name} column, as it has been specified to be ann auto_incremental column with a default value which are contradictory. 
                            If this query was generated by the Lazy_SQL module, 
                            please raise a bug report on https://github.com/walterchoi/Lazy_SQL/issues`
                        })
                    } else {
                        auto_increments_sql += `CREATE SEQUENCE ${table + '_' + column_name};\n`
                        def = "NEXTVAL('" + table + '_' + column_name + "')"
                    }
                }
    
                // If comment is provided then add comment to the table schema
                if(comment !== undefined) {
                    create_table_sql_part += " COMMENT '" + comment + "'"
                }
    
                // If default value is provided then add a default value to the column
                if(def !== undefined) {
                    create_table_sql_part += " SET DEFAULT " + def + ""
                }
    
                // If column is part of the primary key, then add column to the primary constraint index
                if(primary === true) {
                    if(primary_sql_part == null) {
                        primary_sql_part = ", PRIMARY KEY (`" + column_name + "`"
                    } else {
                        primary_sql_part += ", `" + column_name + "`"
                    }
                }
                create_table_sql += create_table_sql_part
            }
    
            // Close off primary_sql_part
            if(primary_sql_part) {
                    primary_sql_part += ")"
                    create_table_sql += primary_sql_part
            }
    
            create_table_sql = create_table_sql + ")"
            if(config.collation) {
                create_table_sql += ' COLLATE ' + config.collation + ';\n'
            } else {
                create_table_sql = create_table_sql + ";\n"
            }
            if(auto_increments_sql.length > 1) {
                create_table_sql = auto_increments_sql + create_table_sql
            }
            if(index_create_sql.length > 1) {
                create_table_sql = create_table_sql + index_create_sql
            }
            resolve (create_table_sql) 
        })
    }
}

            module.exports = {
                exports
            }